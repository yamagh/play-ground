# 6-1. バックエンドでのバリデーション (Play Framework)

ユーザーがフォームから送信するデータが、常にアプリケーションが期待する形式や条件を満たしているとは限りません。空のまま送信されたり、不正な形式のデータが送られてきたりする可能性があります。このような無効なデータからアプリケーションを保護するために、「バリデーション（検証）」が不可欠です。

バリデーションは、フロントエンドとバックエンドの両方で行うべきですが、**最終的なデータの正しさを保証するのはバックエンドの責任**です。なぜなら、悪意のあるユーザーはフロントエンドのチェックを迂回して、直接APIにリクエストを送信できるからです。

この章では、Play Frameworkが提供する強力なバリデーション機能を使って、バックエンドでデータを検証する方法を学びます。

## Play Frameworkのバリデーション機能

Playには、フォームデータのバリデーションを簡単に行うための仕組みが用意されています。主に、モデルに付与するアノテーションと、Controllerで使う `FormFactory` の2つを組み合わせます。

### 1. モデルへのアノテーション追加

まず、`Task` モデルのフィールドに、どのような制約を持たせるかをアノテーションで定義します。

**`app/models/Task.java`**
```java
package models;

// ... (importを追加)
import play.data.validation.Constraints;

// ...

@Entity
public class Task extends BaseModel {
    // ...

    @Constraints.Required(message = "タイトルは必須です。")
    @Constraints.MaxLength(value = 100, message = "タイトルは100文字以内で入力してください。")
    public String title;

    // ...
}
```
- **`@Constraints.Required`**: このフィールドが必須であることを示します。`message` 属性で、バリデーションエラーが発生した際のメッセージをカスタマイズできます。
- **`@Constraints.MaxLength(100)`**: このフィールドの最大長を100文字に制限します。
- 他にも `@Constraints.Min`, `@Constraints.Email`, `@Constraints.Pattern` など、様々なバリデーション用のアノテーションが用意されています。

### 2. Controllerでのバリデーション処理

次に、`TaskController` を修正し、`FormFactory` を使ってリクエストデータを `Task` モデルにバインドし、バリデーションを実行するようにします。

**`app/controllers/api/TaskController.java`**
```java
package controllers.api;

// ... (importを追加)
import play.data.Form;
import play.data.FormFactory;

public class TaskController extends Controller {

    private final TaskRepository taskRepository;
    private final FormFactory formFactory;

    @Inject
    public TaskController(TaskRepository taskRepository, FormFactory formFactory) {
        this.taskRepository = taskRepository;
        this.formFactory = formFactory;
    }

    // ... (list, updateアクションは省略)

    @BodyParser.Of(BodyParser.Json.class)
    public CompletionStage<Result> create(Http.Request request) {
        // 1. リクエストデータをFormオブジェクトにバインド
        Form<Task> taskForm = formFactory.form(Task.class).bindFromRequest(request);

        // 2. バリデーションエラーのチェック
        if (taskForm.hasErrors()) {
            // 3. エラーがあれば、badRequest (400) とエラー内容を返す
            return CompletableFuture.completedFuture(
                badRequest(taskForm.errorsAsJson())
            );
        }

        // 4. エラーがなければ、Taskオブジェクトを取得して保存処理へ
        Task task = taskForm.get();
        task.id = null;
        return taskRepository.save(task).thenApplyAsync(savedTask ->
            created(Json.toJson(savedTask))
        );
    }
    
    // updateアクションも同様に修正が必要です
}
```
- **`FormFactory` の注入**:
  `@Inject` を使って `FormFactory` のインスタンスをControllerに注入します。
- **`formFactory.form(Task.class).bindFromRequest(request)`**:
  - `form(Task.class)`: `Task` クラスに基づいたフォーム定義を作成します。
  - `.bindFromRequest(request)`: HTTPリクエストのボディ（JSON）を解析し、`Task` クラスのフィールドにマッピング（バインド）しようとします。このとき、モデルに付与された `@Constraints` アノテーションに基づいたバリデーションが自動的に実行されます。
- **`taskForm.hasErrors()`**:
  バリデーションの結果、何らかのエラーがあったかどうかを真偽値で返します。
- **`badRequest(taskForm.errorsAsJson())`**:
  エラーがあった場合、HTTPステータスコード `400 Bad Request` を返します。`errorsAsJson()` メソッドは、どのフィールドでどのようなエラーが発生したのかを詳細に記述したJSONを生成してくれます。
- **`taskForm.get()`**:
  バリデーションを通過した場合、リクエストデータがマッピングされた `Task` オブジェクトのインスタンスを取得できます。

## バリデーションエラーのレスポンス

`taskForm.errorsAsJson()` が生成するJSONは、以下のような形式になります。

```json
{
  "title": [
    "タイトルは必須です。"
  ]
}
```
キーがフィールド名、値がそのフィールドで発生したエラーメッセージの配列となります。

この構造化されたエラー情報をフロントエンドで受け取ることにより、「どの入力フィールドの隣に、どのエラーメッセージを表示するか」といった、ユーザーにとって分かりやすいフィードバックを実装することが可能になります。

### 動作確認

Postmanなどのツールを使い、わざとバリデーションルールに違反するリクエストを送信してみましょう。

- **リクエスト (タイトルが空)**
  - URL: `http://localhost:9000/api/tasks`
  - Method: `POST`
  - Body: `{ "title": "" }`
- **レスポンス**
  - Status: `400 Bad Request`
  - Body:
    ```json
    {
      "title": [
        "タイトルは必須です。"
      ]
    }
    ```

---

サーバーサイドでの堅牢なバリデーションは、アプリケーションのデータの整合性を保ち、セキュリティを向上させるための基本です。次の章では、これと並行して、ユーザー体験を向上させるためのフロントエンドでのバリデーションを実装します。
