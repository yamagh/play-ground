# 5-6. エラーハンドリング

アプリケーション開発において、エラーハンドリングは非常に重要です。ユーザーの不正な入力、ネットワークの問題、サーバーの内部エラーなど、予期せぬ事態は常に起こり得ます。堅牢なアプリケーションを構築するためには、これらのエラーを適切に捕捉し、ユーザーに分かりやすくフィードバックする仕組みが必要です。

## バックエンドのエラーハンドリング

Play Frameworkでは、Controllerのアクション内で発生した例外（Exception）をハンドリングするための仕組みが提供されています。

### Controllerでの例外処理

Javaの標準的な `try-catch` ブロックを使うこともできますが、非同期処理（`CompletionStage`）の場合は `.exceptionally()` メソッドを使うと、より簡潔にエラーハンドリングを記述できます。

**`app/controllers/api/TaskController.java` (エラーハンドリングの例)**
```java
public CompletionStage<Result> create(Http.Request request) {
    return CompletableFuture.supplyAsync(() -> {
        JsonNode json = request.body().asJson();
        // わざと例外を発生させる
        if (true) throw new RuntimeException("Something went wrong!");
        Task task = Json.fromJson(json, Task.class);
        return task;
    })
    .thenComposeAsync(task -> taskRepository.save(task))
    .thenApplyAsync(savedTask -> created(Json.toJson(savedTask)))
    .exceptionally(throwable -> {
        // 例外が発生した場合、このブロックが実行される
        // エラーログを記録
        Logger.error("Failed to create task", throwable);
        // ユーザーには汎用的なエラーメッセージを返す
        ObjectNode result = Json.newObject();
        result.put("error", "An unexpected error occurred.");
        return internalServerError(result); // HTTP 500 Internal Server Error
    });
}
```
- **`.exceptionally(throwable -> { ... })`**:
  `thenComposeAsync` や `thenApplyAsync` の処理中に例外が発生した場合に、その例外（`throwable`）を引数としてコールバックが実行されます。
- **エラーログの記録**:
  開発者が問題を追跡できるように、サーバー側のログにエラーの詳細を記録しておくことが重要です。
- **ユーザーへのレスポンス**:
  セキュリティ上の理由から、データベースのエラーメッセージなど、内部的なエラーの詳細をそのままユーザーに返すのは避けるべきです。代わりに、「予期せぬエラーが発生しました」のような汎用的なメッセージと共に、適切なHTTPステータスコード（サーバー内部のエラーなら `500 Internal Server Error`、クライアントからの入力が原因なら `400 Bad Request` など）を返します。

### グローバルなエラーハンドラー

個々のアクションでエラーハンドリングを記述する代わりに、アプリケーション全体で発生した未捕捉の例外を処理するためのグローバルなエラーハンドラー（`ErrorHandler`）を実装することもできます。これにより、エラーハンドリングのロジックを一元化できます。
（このプロジェクトでは `app/libraries/ErrorHandler.java` がその役割を担います）

## フロントエンドのエラーハンドリング

バックエンドがエラーレスポンスを返した場合、フロントエンドはそれを受け取ってユーザーに通知する必要があります。

### API呼び出しの `try-catch`

`utils/api.ts` のAPIクライアントは、サーバーがエラー（400番台や500番台のステータスコード）を返した場合にPromiseを `reject` するように作られています。そのため、`async/await` 構文と組み合わせることで、`try-catch` ブロックを使ってAPIエラーを簡単に捕捉できます。

**`app/assets/svelte/screens/task-edit/Page.svelte`**
```svelte
<script lang="ts">
  // ... (importを追加)
  import { showError } from '~/stores/message';

  // ...

  async function handleSubmit() {
    try {
      // ... (成功時の処理)
    } catch (e) {
      console.error(e);
      // エラーメッセージストアを更新
      showError('エラーが発生しました。しばらくしてからもう一度お試しください。');
    }
  }
</script>
```
- **`catch (e)`**:
  API呼び出し（`api.put` や `api.post`）が失敗すると、`catch` ブロックが実行されます。
- **`showError(...)`**:
  `message.ts` に用意されている、エラーメッセージを表示するためのヘルパー関数です。これを呼び出すことで、画面上部に赤い `Alert` コンポーネントでエラーメッセージが表示されます。

### より詳細なエラーフィードバック

バックエンドから返されたエラーレスポンスのボディに、`{ "error": "タイトルは必須です" }` のような具体的なエラーメッセージが含まれている場合、それをパースして表示することもできます。

```typescript
// catchブロック内
catch (e) {
  console.error(e);
  if (e.response && e.response.data && e.response.data.error) {
    // バックエンドからのエラーメッセージがあればそれを表示
    showError(e.response.data.error);
  } else {
    // なければ汎用的なメッセージを表示
    showError('エラーが発生しました。');
  }
}
```
これにより、ユーザーは何が問題だったのかを具体的に知ることができ、次のアクションを取りやすくなります。

---

適切なエラーハンドリングは、アプリケーションの信頼性とユーザー体験を向上させるための重要な要素です。成功時の流れ（ハッピーパス）だけでなく、常にエラーケースを想定して設計・実装する習慣をつけましょう。
