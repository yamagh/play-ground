# 24. エラーハンドリング

API呼び出しは、ネットワークの問題やサーバー側のエラーなど、さまざまな理由で失敗する可能性があります。
エラーが発生した際に、それを適切に捕捉（キャッチ）し、ユーザーに状況を通知することは、堅牢なアプリケーションを構築する上で非常に重要です。

## `try...catch` による基本的なエラーハンドリング

JavaScriptでエラーを処理する最も基本的な方法は、`try...catch` ブロックを使うことです。

```javascript
async function doSomething() {
  try {
    // エラーが発生する可能性のある処理
    const result = await someApiCall();
    // 成功した場合の処理
  } catch (error) {
    // エラーが発生した場合の処理
    console.error("An error occurred:", error);
    // ユーザーにエラーメッセージを表示
    showError("操作に失敗しました。");
  }
}
```
`try` ブロック内で `await` した非同期処理が失敗（Promiseが `rejected` になる）すると、実行は直ちに `catch` ブロックに移り、エラーオブジェクトが `error` 変数に渡されます。

しかし、APIを呼び出すたびに毎回同じような `try...catch` ブロックを記述するのは冗長です。

## `safeRun` ヘルパーによる共通化

このプロジェクトでは、この定型的な `try...catch` の処理を共通化するための `safeRun.ts` というヘルパー関数が用意されています。

**`@app/assets/svelte/utils/safeRun.ts`**:
```typescript
import { showError } from "@app/assets/svelte/stores/message";

/**
 * 関数を安全に実行し、エラーが発生した場合は共通のエラーメッセージを表示します。
 * @param fn 実行する関数 (Promiseを返す非同期関数)
 */
export const safeRun = async (fn: () => Promise<void>) => {
  try {
    await fn();
  } catch (error) {
    console.error("Operation failed:", error);
    // messageストアを使って共通のエラーメッセージを表示
    showError("An unexpected error occurred. Please try again.");
  }
};
```
`safeRun` は、引数として実行したい非同期関数 `fn` を受け取ります。そして、その関数を内部の `try...catch` ブロックでラップして実行します。
もしエラーが発生した場合は、`catch` ブロックでそれを捕捉し、前章で学んだ `message` ストアの `showError` 関数を呼び出して、画面に共通のエラーメッセージを表示します。

## `safeRun` の使い方

この `safeRun` ヘルパーを使うと、コンポーネント側のエラーハンドリングの記述を大幅に簡潔にできます。

`task-edit/Page.svelte` の `handleSubmit` 関数を `safeRun` を使って書き換えてみましょう。

**`task-edit/Page.svelte`**:
```svelte
<script lang="ts">
  import { safeRun } from "@app/assets/svelte/utils/safeRun";
  // ...

  const handleSubmit = async () => {
    // safeRunでラップする
    await safeRun(async () => {
      if (isEditMode) {
        await updateTask(id, task);
      } else {
        await createTask(task);
      }
      showSuccess("Task saved successfully.");
      goto("/tasks");
    });
  };
</script>
```
元のコードにあった `try...catch` ブロックが不要になり、成功した場合のロジックだけを記述すればよくなりました。
`updateTask` や `createTask` でエラーが発生した場合、`safeRun` がそれを自動的にキャッチし、画面にエラーメッセージを表示してくれます。

このように、繰り返し現れる定型的な処理を共通のヘルパー関数として切り出すことは、コードの量を減らし、可読性を高め、アプリケーション全体の保守性を向上させるための良いプラクティスです。
