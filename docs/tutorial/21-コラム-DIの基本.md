# 21. コラム: DIの基本 (Dependency Injection)

`TaskController` のコンストラクタに `@Inject` というアノテーションが登場しました。
これは、**DI (Dependency Injection / 依存性の注入)** という、ソフトウェア設計における重要なパターンを実現するためのものです。

## DIとは何か？

DIを理解するために、まずはDIを使わない場合のコードを見てみましょう。

```java
// DIを使わない例
public class TaskController extends Controller {

    private final TaskRepository taskRepository;

    public TaskController() {
        // Controller自身が、依存するTaskRepositoryのインスタンスを生成している
        this.taskRepository = new TaskRepository();
    }

    // ...
}
```
このコードでは、`TaskController` が動作するために必要な `TaskRepository` のインスタンスを、`TaskController` 自身が `new` を使って生成しています。
一見問題ないように見えますが、これにはいくつかの欠点があります。

- **密結合**: `TaskController` が `TaskRepository` という具体的なクラスに強く依存してしまっています。もし `TaskRepository` の代わりに、テスト用の `MockTaskRepository` を使いたくなった場合、`TaskController` のコードを書き換える必要が出てきます。
- **柔軟性の欠如**: `TaskRepository` が、さらに別のクラス（例: `DatabaseExecutionContext`）を必要とするように変更された場合、`TaskController` のコンストラクタも修正しなければならなくなります。

**DIは、このようなクラス間の依存関係を、クラスの内部から外部に移す**ためのデザインパターンです。
「依存性の注入」という名前の通り、クラスが必要とするオブジェクト（依存性）を、自分自身で生成するのではなく、外部から与えて（注入して）もらう、という考え方です。

## `@Inject` の役割

Play Frameworkは、GuiceというDIコンテナを内蔵しています。
DIコンテナは、アプリケーション内のオブジェクトの生成と、それらの間の依存関係の管理を自動的に行ってくれるフレームワークです。

`@Inject` アノテーションは、DIコンテナに対して「ここに、このクラスが必要としているオブジェクトを注入してください」と指示するためのマーカーです。

```java
// DIを使う例
public class TaskController extends Controller {

    private final TaskRepository taskRepository;

    @Inject // DIコンテナへの指示
    public TaskController(TaskRepository taskRepository) {
        // TaskRepositoryのインスタンスは、外部 (DIコンテナ) から渡される
        this.taskRepository = taskRepository;
    }

    // ...
}
```

## Play FrameworkにおけるDIの流れ

1.  Play Frameworkは、`TaskController` のインスタンスを生成しようとします。
2.  コンストラクタに `@Inject` が付いていることを見つけます。
3.  コンストラクタの引数 `TaskRepository taskRepository` を見て、「`TaskController` は `TaskRepository` のインスタンスを必要としている」ことを理解します。
4.  DIコンテナは、自身が管理している `TaskRepository` のインスタンスを探しに行きます。（もし存在しなければ、新しく生成します）
5.  見つけた `TaskRepository` のインスタンスを `TaskController` のコンストラクタの引数に渡して、`TaskController` のインスタンスを生成します。

## DIのメリット

- **疎結合**: `TaskController` は、`TaskRepository` の具体的な実装を知らなくても、その機能（インターフェース）だけを利用できます。これにより、クラス間の結合度が下がり、コードがよりモジュール化されます。
- **テストの容易性**: テスト時には、本物の `TaskRepository` の代わりに、DIコンテナにモックオブジェクトを登録することで、`TaskController` のロジックだけを単体でテストすることが容易になります。
- **柔軟性と拡張性**: 依存関係が一箇所（DIコンテナ）で管理されるため、アプリケーションの構成変更が容易になります。

DIは、大規模で保守性の高いアプリケーションを構築するための基本的なテクニックであり、Play Frameworkでは標準的な開発スタイルとなっています。
