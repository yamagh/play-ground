# 18. コラム: 非同期処理 (Promise と async/await)

API呼び出しのようなネットワーク通信は、完了するまでにどれくらいの時間がかかるか予測できません。サーバーの応答が速いこともあれば、ネットワークが混雑していて数秒かかることもあります。

もし、JavaScriptがAPIの応答を待っている間、他の処理をすべて停止（ブロック）してしまうと、ユーザーの画面はフリーズし、ボタンをクリックしても反応しない、といった事態に陥ってしまいます。

このような問題を解決するのが「非同期処理」です。

## 非同期処理とは？

非同期処理とは、時間のかかる処理（例: API呼び出し、ファイルの読み込み）を開始した後、その完了を待たずに、すぐに次の処理へ進むプログラミングモデルのことです。
そして、時間のかかる処理が完了したら、予め登録しておいたコールバック関数が呼び出され、後続の処理が実行されます。

これにより、重い処理の最中でも、UIの操作を受け付けるなど、アプリケーションの応答性を保つことができます。

## Promise: 非同期処理の状態を表現するオブジェクト

かつてのJavaScriptでは、非同期処理を扱うためにコールバック関数を多用していましたが、処理が複雑になるとコールバックが入れ子になり、「コールバック地獄」と呼ばれる読みにくいコードになりがちでした。

この問題を解決するために導入されたのが `Promise` です。
`Promise` は、非同期処理の最終的な結果（成功または失敗）を表すオブジェクトです。

`Promise` は、以下の3つのいずれかの状態を持ちます。

- **`pending`**: 初期状態。まだ処理が完了していない。
- **`fulfilled`**: 処理が成功して完了した。結果の値を持つ。
- **`rejected`**: 処理が失敗して完了した。エラーの理由を持つ。

`fetch` APIは、`Promise` を返す関数の代表例です。

```javascript
fetch('/api/tasks')
  .then(response => {
    // 成功した場合 (fulfilled) の処理
    return response.json();
  })
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    // 失敗した場合 (rejected) の処理
    console.error('Error:', error);
  });
```
`.then()` で成功時の処理を、`.catch()` で失敗時の処理をチェーンのようにつなげて記述できます。

## async/await: 同期処理のように書けるシンタックスシュガー

`Promise` はコールバック地獄を解決しましたが、それでもコードが冗長になることがあります。
そこで導入されたのが `async/await` です。これは、`Promise` をベースにした非同期処理を、まるで同期処理であるかのように直感的に書けるようにする、JavaScriptのシンタックスシュガー（糖衣構文）です。

- **`async`**: 関数を宣言する際に先頭に付けると、その関数が常に `Promise` を返す非同期関数であることを示します。
- **`await`**: `async` 関数内でのみ使用できます。`Promise` を返す式の前に置くと、その `Promise` が解決される（`fulfilled` または `rejected` になる）まで、関数の実行を一時停止します。そして、`Promise` が成功すればその結果の値を返し、失敗すれば例外をスローします。

先ほどの `fetch` の例を `async/await` で書き換えると、以下のようになります。

```javascript
// async関数として定義
async function fetchTasks() {
  try {
    // awaitでPromiseの結果を待つ
    const response = await fetch('/api/tasks');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
```

コードのネストが減り、上から下へ順番に実行されるように見えるため、処理の流れが格段に理解しやすくなります。
SvelteコンポーネントやAPI呼び出しのロジックでは、この `async/await` を使うのが現在の主流となっています。
