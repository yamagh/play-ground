# 4-5. コラム: 非同期処理とPromise/async/await

前の章で、`onMount` の中で `async () => { ... }` や `await api.get(...)` といった構文を使いました。これは、JavaScriptにおける「非同期処理」を扱うための仕組みです。なぜこのような仕組みが必要で、どのように動作するのかを理解することは、Web APIを利用するフロントエンド開発において非常に重要です。

## なぜ非同期処理が必要か

JavaScriptは、基本的に「シングルスレッド」で動作します。これは、一度に一つの処理しか実行できない、という意味です。

もし、API通信のような時間のかかる処理を「同期的」に実行してしまうと、どうなるでしょうか？

1.  ユーザーがボタンをクリックする。
2.  JavaScriptがAPIリクエストを送信する。
3.  サーバーからの応答が返ってくるまで、**JavaScriptの実行が完全に停止（ブロック）する**。
4.  この間、ユーザーはスクロールしたり、他のボタンをクリックしたり、テキストを入力したりといった**一切の操作ができなくなる**（UIがフリーズする）。
5.  数秒後、応答が返ってきたら、ようやくJavaScriptの実行が再開され、UIが再び操作可能になる。

これではユーザー体験が著しく損なわれます。

そこで「**非同期処理**」の出番です。非同期処理では、時間のかかる処理（API通信、ファイルの読み込みなど）を開始した後、その完了を待たずにすぐに次の処理へ進みます。そして、時間のかかる処理が完了した時点で、あらかじめ登録しておいたコールバック関数（後で実行される関数）が呼び出され、後続の処理が行われます。

これにより、重い処理の実行中もJavaScriptのメインスレッドはブロックされず、UIはスムーズに動作し続けることができます。

## Promiseとは

非同期処理をより構造化して扱いやすくするために、ES2015 (ES6) で導入されたのが `Promise` オブジェクトです。

`Promise` は、非同期処理の**最終的な結果（成功または失敗）を表すオブジェクト**です。`new Promise(...)` で生成された時点では、まだ処理が完了していない「**pending**（待機中）」という状態です。

その後、非同期処理が成功すると、`Promise` は「**fulfilled**（成功）」状態になり、結果の値を保持します。処理が失敗すると、「**rejected**（失敗）」状態になり、エラー情報を保持します。

`Promise` を使うと、`.then()` メソッドで成功時の処理を、`.catch()` メソッドで失敗時の処理を、メソッドチェーンの形で記述できます。

```javascript
// fetch APIはPromiseを返す
fetch('/api/tasks')
  .then(response => {
    // 成功時の処理 (fulfilled)
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json(); // この処理もPromiseを返す
  })
  .then(data => {
    console.log('取得したデータ:', data);
  })
  .catch(error => {
    // 失敗時の処理 (rejected)
    console.error('エラーが発生しました:', error);
  });
```

## async/awaitによる直感的な記述

`.then()` チェーンはコールバック地獄（ネストが深くなる問題）を解決しましたが、それでも処理の流れが直感的に分かりにくい場合があります。

そこでES2017で導入されたのが `async/await` です。これは、`Promise` を使った非同期処理を、まるで同期処理のように直感的な構文で書けるようにする「糖衣構文（シンタックスシュガー）」です。

- **`async`**:
  関数を宣言する際に `async` キーワードを付けると、その関数は常に `Promise` を返す「非同期関数」になります。

- **`await`**:
  `async` 関数の中でのみ使用できます。`await` の後ろに `Promise` を置くと、その `Promise` の状態が `fulfilled` になるまで関数の実行を**一時停止**し、`fulfilled` になったらその結果の値を取り出して処理を再開します。もし `Promise` が `rejected` になった場合は、例外（exception）をスローします。

`async/await` を使うと、先ほどの `fetch` の例は以下のように書き換えられます。

```javascript
// このコードは async 関数の中で実行する必要がある
async function fetchTasks() {
  try {
    const response = await fetch('/api/tasks');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    console.log('取得したデータ:', data);
  } catch (error) {
    console.error('エラーが発生しました:', error);
  }
}
```
コードが上から下へと直線的に実行されるように見え、`try...catch` で同期処理と同じようにエラーハンドリングができるため、非常に可読性が高くなります。

`onMount(async () => { ... })` で行ったのは、まさにこの `async/await` を使った非同期処理の実装だったのです。
