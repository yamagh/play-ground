# 6-2. フロントエンドでのバリデーション (Svelte)

バックエンドでバリデーションを実装しましたが、ユーザーが「保存」ボタンを押してサーバーからの応答を待って初めてエラーを知る、という体験はあまり親切ではありません。

フロントエンドでのバリデーションは、ユーザーがフォームに入力している最中にリアルタイムでフィードバックを提供し、エラーを即座に修正できるようにガイドすることを目的とします。これにより、ユーザー体験が大幅に向上し、サーバーへの不要なリクエストを減らすことにも繋がります。

**重要**: フロントエンドのバリデーションは、あくまでユーザー体験向上のための補助的なものです。最終的なデータの正当性は、常にバックエンドのバリデーションで保証する必要があります。

## リアルタイムバリデーション

Svelteのイベントハンドリング機能を使うと、リアルタイムバリデーションを簡単に実装できます。

- **`on:input`**: ユーザーが入力フィールドの内容を**変更するたびに**イベントが発生します。最もリアルタイム性が高いフィードバックに適しています。
- **`on:blur`**: ユーザーが入力フィールドから**フォーカスを外したとき**にイベントが発生します。入力を終えたタイミングで一度だけチェックしたい場合に適しています。

### バリデーションロジックの実装

`task-edit/Page.svelte` に、入力値をチェックするためのロジックを追加しましょう。

**`app/assets/svelte/screens/task-edit/Page.svelte`**
```svelte
<script lang="ts">
  // ... (既存のimportは省略)

  let task = $state<Partial<Task>>({
    title: '',
    isDone: false
  });
  
  // エラーメッセージを保持するためのリアクティブな状態
  let errors = $state<{ title?: string }>({});

  // タイトルをバリデーションする関数
  function validateTitle() {
    if (!task.title) {
      errors.title = 'タイトルは必須です。';
    } else if (task.title.length > 100) {
      errors.title = 'タイトルは100文字以内で入力してください。';
    } else {
      errors.title = undefined; // エラーがなければクリア
    }
  }

  // $effectを使って、task.titleが変更されるたびにバリデーションを実行
  $effect(() => {
    // 最初の入力前からエラーを表示しないように、一度でも入力があったかなどを
    // 管理するフラグ（isDirty）を設けるのが一般的ですが、ここでは簡略化します。
    validateTitle();
  });

  async function handleSubmit() {
    // 送信前にもバリデーションを実行
    validateTitle();
    if (Object.values(errors).some(e => e)) {
      // エラーがあれば送信を中止
      return;
    }
    // ... (API送信処理)
  }

  // ...
</script>
```
- **`let errors = $state<{...}>({});`**:
  各フィールドのエラーメッセージを保持するためのオブジェクトを `$state` で宣言します。
- **`validateTitle()`**:
  `task.title` の値をチェックし、条件に応じて `errors.title` の値を更新する関数です。
- **`$effect(() => { ... })`**:
  Svelte 5の `$effect` を使うと、リアクティブな値（ここでは `task.title`）が変更されるたびに特定の処理（`validateTitle()`）を自動的に実行できます。これにより、ユーザーの入力に即座に反応するリアルタイムバリデーションが実現できます。
- **`handleSubmit()` 内のチェック**:
  フォームを送信する直前にもバリデーションを実行し、エラーが一つでも存在すればAPIリクエストを送信しないようにします。

## バリデーション結果の表示

バリデーションロジックができたので、次はその結果をUIに反映させます。エラーがある場合は入力フィールドの下にメッセージを表示し、フィールドの枠を赤くする、といった視覚的なフィードバックを実装します。

**`app/assets/svelte/screens/task-edit/Page.svelte` (テンプレート部分)**
```svelte
<FormGroup>
  <Label for="title">Title</Label>
  <Input
    id="title"
    name="title"
    bind:value={task.title}
    required
    invalid={!!errors.title}
  />
  {#if errors.title}
    <div class="invalid-feedback d-block">{errors.title}</div>
  {/if}
</FormGroup>
```
- **`invalid={!!errors.title}`**:
  Sveltestrapの `Input` コンポーネントの `invalid` プロパティに、エラーが存在するかどうかの真偽値を渡します。`!!errors.title` は、`errors.title` に文字列が入っていれば `true`、`undefined` や空文字列なら `false` に変換するJavaScriptのイディオムです。`invalid` が `true` になると、Bootstrapのスタイルによって入力フィールドの枠が赤くなります。
- **`{#if errors.title}`**:
  エラーメッセージが存在する場合のみ、その内容を表示します。`invalid-feedback` はBootstrapのクラスで、エラーメッセージ用のスタイルを提供します。`d-block` を追加して常に表示されるようにしています。

## バックエンドとの連携

最後に、バックエンドのバリデーション結果をフロントエンドに反映させる部分を考えます。フロントエンドのチェックを通過しても、サーバー側でより複雑な（例えば、データベース内のデータとの重複チェックなど）バリデーションによってエラーが返される可能性があります。

`handleSubmit` 関数の `catch` ブロックを修正し、バックエンドから `400 Bad Request` が返ってきた場合の処理を追加します。

```typescript
async function handleSubmit() {
  // ... (フロントエンドバリデーション)
  try {
    // ... (API送信処理)
  } catch (e) {
    console.error(e);
    if (e.response && e.response.status === 400) {
      // バックエンドからのバリデーションエラー
      const backendErrors = e.response.data;
      // 例: { title: ["タイトルは必須です。"] }
      // この情報をerrorsステートに反映させる
      Object.keys(backendErrors).forEach(key => {
        errors[key] = backendErrors[key].join(', ');
      });
    } else {
      // その他のAPIエラー
      showError('エラーが発生しました。');
    }
  }
}
```
バックエンドから返されたJSON形式のエラー (`e.response.data`) を解析し、フロントエンドの `errors` 状態にマッピングします。これにより、サーバー側で検知されたエラーも、フロントエンドのリアルタイムバリデーションと同じUIでユーザーにフィードバックすることができます。

---

これで、ユーザー体験とデータの堅牢性の両方を向上させる、二段構えのバリデーションが完成しました。
